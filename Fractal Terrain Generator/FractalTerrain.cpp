#include <GL/glu.h>
#include <glm/glm.hpp>
#include <QGLWidget>
#include <QString>
#include <string>
#include <vector>
#include <stdlib.h>
#include <cmath>
#include <ctime>
#include <iostream>
#include <fstream>
#include <sstream>
#include "fftw3.h"
#include "FractalTerrain.h"

using namespace std;
using namespace glm;

// Structure for defining a material according to the Blinn-Phong lighting model
typedef struct material {
  GLfloat ambient[4];
  GLfloat diffuse[4];
  GLfloat specular[4];
  GLfloat shininess;
} material;

static material colour = {
	{0.0, 1.0, 0.0, 1.0},
	{0.0, 1.0, 0.0, 1.0},
	{0.45, 0.55, 0.45, 1.0},
	5.0f
};

// Global Heightmap array for storing the values generated by the algorithms.
double HeightMap[1024][1024] = {0, 0};

// Initialisor 
FractalTerrain::FractalTerrain(QWidget *parent)
  : QGLWidget(parent), 
	angle(0), 
	mode(1), 
	waterlevel(0),
	roughness(8),
	featuresize(32),
	mastersize(128),
	scale(4)
	{
		// Seeds the random number generator upon initialisation.
		srand(unsigned(time(NULL)));

		// Generates a heightmap using the dafult values so that one exists upon startup.
		GenerateDSMap(mastersize, featuresize);
  		DiamondSquare(featuresize, roughness);
	}

//Public slot for updating the angle of rotation, connected to rotationSlider in TerrainWindow.cpp.
void FractalTerrain::updateAngle(int i){
  	angle = i*3;
  	this->repaint();
}

//Public slot for updating the water level, connected to waterSlider in TerrainWindow.cpp.
void FractalTerrain::changeWater(int i){
	waterlevel = i;
	this->repaint();
}

//Public slot for changing the roughness parameter, passed to it via a connection to the roughness Spin Box in TerrainWindow.cpp.
void FractalTerrain::changeRoughness(double i){
	roughness = i;

}
//Public slot for changing the featuresize parameter, passed to it via a connection to the featuresize Combo Box in TerrainWindow.cpp.
void FractalTerrain::changeFeature(QString i){
	//The value of the signal is of type QString, so it is converted to integer.
	featuresize = i.toInt();

}

//Public slot for changing size of the array to be generated, passed to it via a connection to the changeSize Spin Box in TerrainWindow.cpp.
void FractalTerrain::changeSize(QString i){
	//Converting QString to int
	mastersize = i.toInt();

	//Changing the scaling of the map during rendering so that the displayed image is the same size regardless of array size.
	if (mastersize == 16){
		scale = 20;
	} else if (mastersize == 32){
		scale = 10;
	} else if (mastersize == 64){
		scale = 8;
	} else if (mastersize == 128){
		scale = 4;
	} else if (mastersize == 256){
		scale = 2;
	} else if (mastersize == 512){
		scale = 1;
	} else if (mastersize == 1024){
		scale = 0.5;
	}

}

// Public slots for changing the mode of generation, either DS or FFT. Connected to the RadioButtons in TerrainWindow.cpp.
void FractalTerrain::changeModeDS(){
	mode = 1;
}

void FractalTerrain::changeModeFFT(){
	mode = 2;
}

// Public slot to call the actual functions that generate the heightmap with the given parameters.
void FractalTerrain::generate(){

	//The block commented code was used for evaulation purposes.
	/*
	ofstream f;
	f.open("eval.txt", fstream::app);
	f << mastersize << ", " << featuresize << ", " << roughness << "\n";

	clock_t start;
	double duration;
	start = clock();
	*/
	
	if (mode == 1){
		// Calling the algorithm to generate the initial map, then to use that initial map to create the heightmap. 
		GenerateDSMap(mastersize, featuresize);
  		DiamondSquare(featuresize, roughness);
	} else if (mode == 2){
		//Generating random noise in the heightmap, then calling the FFT method on the map.
		GenerateFFTMap(mastersize);
		FFTMethod(roughness);
	}

	//The block commented code was used for evaulation purposes

	/*
	duration = (clock() - start ) / (double) CLOCKS_PER_SEC;
	f << "Algorithm Time: " << duration << "\n";
	*/

	// Repaints the widget so as to display the terrain 
	this->repaint();
	
}

//Public slot connected to the export button in TerrainWindow.cpp, to export the heightmap to a text file.
void FractalTerrain::exportMap(){
	ofstream f;
	// Opens the file under the name heightmap.txt 
	f.open("heightmap.txt");
	// First writing the current size of the map to the top of the file, to be used during import.
	f << mastersize << "\n";
	// Writes each value of the heightmap onto its own line/
	for(int x = 0; x <= mastersize-1; x += 1){
    	for (int z = 0; z <= mastersize-1; z += 1){
			f << readMap(x, z) << "\n";
		}
	}
	// Closes the file
	f.close();
	
}

void FractalTerrain::importMap(){	
	ifstream f;
	string value;
	int size;
	double pos;
	// Opens the file if it exists
	f.open("heightmap.txt");
	// Basic validation to check if the file was opened, otherwise do nothing.
	if (f.is_open()){
		//Gets the size of the stored heightmap from the top of the file.
		getline(f, value);
		size = stoi(value);
		mastersize = size;

		// Uses the size in the for a for loop to iterate through each line of the file and read the stored heightmap.
		// into memory correctly
		for(int x = 0; x <= size-1; x += 1){
			for (int z = 0; z <= size-1; z += 1){
				getline(f, value);
				pos = stod(value);
				writeMap(x, z, pos);
			}
		}
		f.close();
		// Calls the change size function with the read size, to ensure scaling is correct.
		changeSize(QString::number(size));

		this->repaint();
	} 
}

// Called when OpenGL sets up the context.
void FractalTerrain::initializeGL()
	{

	//Sets the background colour to a neutral light grey.
	glClearColor(0.5, 0.5, 0.5, 1);
		
		//Enables normalize for normal vector usage.
		glEnable(GL_NORMALIZE);
		glMatrixMode(GL_PROJECTION);
		glMatrixMode(GL_MODELVIEW);
 	}

// Destructor for the widget.
FractalTerrain::~FractalTerrain()
{

}

// Function to generate a random number between two values.
double FractalTerrain::getRand(double min, double max){

	// Swaps the values if the first is greater than the second.
	if (min > max){
		std::swap(min, max);
	}
	// Returns a random number in the given range.
	return min + (double)rand() * (max - min) / (double)RAND_MAX;
}

// Function to write to the heightmap, given a position and a value to write.
void FractalTerrain::writeMap(int x, int z, double value){

	// Validation to ensure the given position is within the bounds of the array.
	while (x >= mastersize){
		x -= mastersize;
	}
	while (x < 0){
		x += mastersize;
	}
	while (z >= mastersize){
		z -= mastersize;
	}
	while (z < 0){
		z += mastersize;
	}
	HeightMap[x][z] = value;

}

//Function to read a value at the given position from the heightmap.
double FractalTerrain::readMap(int x, int z){

	// Similar valildation as in writeMap.
	while (x >= mastersize){
		x -= mastersize;
	}
	while (x < 0){
		x += mastersize;
	}
	while (z >= mastersize){
		z -= mastersize;
	}
	while (z < 0){
		z += mastersize;
	}
	return HeightMap[x][z];
}

// Function to generate the initial map for the Diamond-Square algorithm.
void FractalTerrain::GenerateDSMap(int size, int featuresize){

	// Writes random values to each corner of the array.
	writeMap(0,0, getRand(-3, 3));
	writeMap(0,size-1, getRand(-3, 3));
	writeMap(size-1,0, getRand(-3, 3));
	writeMap(size-1,size-1, getRand(-3, 3));

	// Writes random values to the array at steps equaling the feature size, giving the DS Algorithm values to work with.
	for( int x = 0; x <= size-1; x += featuresize){
    	for (int z = 0; z <= size-1; z += featuresize){
        	writeMap(x, z, getRand(-3, 3));
		}
	}
}

// Function to generate the random noise for the FFT.
void FractalTerrain::GenerateFFTMap(int size){

	for( int x = 0; x < size-1; x += 1){
    	for (int z = 0; z < size-1; z += 1){
        	writeMap(x, z, getRand(-5, 5));
		}
	}
	
}

// Function to perform the Fast Fourier Transform Method using the FFTW Library.
void FractalTerrain::FFTMethod(double r){
	int n = mastersize;
	double *in;
	double *out;
	fftw_plan p, q;

	// Performing 1D FFTs on each row of the array
	for( int x = 0; x < mastersize; x += 1){
		in = (double*) fftw_malloc(sizeof(double) * n);
		out = (double*) fftw_malloc(sizeof(double) * n);
		// Assigning the current row of tha array to an array to serve as the FFT input
    	for (int z = 0; z < mastersize; z += 1){
			in[z] = readMap(x, z);
		}

		p = fftw_plan_r2r_1d(n, in, out, FFTW_R2HC, FFTW_ESTIMATE);
		fftw_execute(p);

		// Taking the output array and assigning it back to current row of the heightmap.
		for (int z = 0; z < mastersize; z += 1){
			writeMap(x, z, out[z]);
		}

		fftw_destroy_plan(p);
  		fftw_free(in);
		fftw_free(out);
	}

	// Same as above but for each column of the array.
	for( int z = 0; z < mastersize; z += 1){
		in = (double*) fftw_malloc(sizeof(double) * n);
		out = (double*) fftw_malloc(sizeof(double) * n);
    	for (int x = 0; x < mastersize; x += 1){
			in[x] = readMap(x, z);
		}
		
		p = fftw_plan_r2r_1d(n, in, out, FFTW_R2HC, FFTW_ESTIMATE);
		fftw_execute(p);

		for (int x = 0; x < mastersize; x += 1){
			writeMap(x, z, out[x]);
		}
		fftw_destroy_plan(p);
  		fftw_free(in);
		fftw_free(out);
	}

	// Scaling the transformed values with by a pink noise filter.
	for( int z = 0; z < mastersize; z += 1){
		for (int x = 0; x < mastersize; x += 1){
			HeightMap[x][z] = HeightMap[x][z] * 1/r ;
		}
	}

	// Performing the inverse FFT over the array.	
	for( int x = 0; x < mastersize; x += 1){
		in = (double*) fftw_malloc(sizeof(double) * n);
		out = (double*) fftw_malloc(sizeof(double) * n);
    	for (int z = 0; z < mastersize; z += 1){
			in[z] = readMap(x, z);
		}

		q = fftw_plan_r2r_1d(n, in, out, FFTW_HC2R, FFTW_ESTIMATE);
		fftw_execute(q);

		for (int z = 0; z < mastersize; z += 1){
			writeMap(x, z, out[z]);
		}
		fftw_destroy_plan(q);
  		fftw_free(in);
		fftw_free(out);
	}


	for( int z = 0; z < mastersize; z += 1){
		in = (double*) fftw_malloc(sizeof(double) * n);
		out = (double*) fftw_malloc(sizeof(double) * n);
    	for (int x = 0; x < mastersize; x += 1){
			in[x] = readMap(x, z);
		}
		
		q = fftw_plan_r2r_1d(n, in, out, FFTW_HC2R, FFTW_ESTIMATE);
		fftw_execute(q);

		for (int x = 0; x < mastersize; x += 1){
			writeMap(x, z, out[x]);
		}
		fftw_destroy_plan(q);
  		fftw_free(in);
		fftw_free(out);
	}
	


	
}

// Function to perform the square step of the Diamond-Square.
void FractalTerrain::Square(int x, int z, int step, double range){
	int count = 0;
	double value = 0;
	double average = 0;
	double shift;
	int bounds = mastersize - 1;
	// Looking for the four corners of the square. 
	// Also checking that they aren't outside of the bounds of the array.
	if (((x-step) >= 0) && (((z - step) >= 0))){
		average += readMap(x-step, z-step);
		count++;
	}
	if (((x-step) >= 0) && (((z + step) <= bounds))){
		average += readMap(x-step, z+step);
		count++;
	}
	if (((x+step) <= bounds) && (((z - step) >= 0))){
		average += readMap(x+step, z-step);
		count++;
	}
	if (((x+step) <= bounds) && (((z + step) <= bounds))){
		average += readMap(x+step, z+step);
		count++;
	}

	// Calculating the perturbation for the value in the center of the square.
	shift = getRand(-range, range);	
	value = (average/count)+shift;

	writeMap(x, z, value);
}

// Function for performing the Diamond Step of the Diamond-Square.
void FractalTerrain::Diamond(int x, int z, int step, double range){
	int count = 0;
	double value = 0;
	double average = 0;
	double shift;
	int bounds = mastersize-1;
	// Looking for the four corners of the diamond.
	// Checking for whether the value is outside of the array also.
	if (((x - step) >= 0)){
		average += readMap(x-step, z);
		count++;
	}
	if (((z - step) >= 0)){
		average += readMap(x,z-step);
		count++;
	}
	if (((x+step) <= bounds)){
		average += readMap(x+step, z);
		count++;
		
	}
	if (((z + step) <= bounds)){
		average += readMap(x, z+step);
		count++;
	}

	shift = getRand(-range, range);

	value = (average/4)+shift;

	writeMap(x, z, value);
}

// Recursive function perform the Diamond-Square Algorithm.
void FractalTerrain::DiamondSquare(int step, double range){
	int half= step/2;
	
	// If the step is less than one then all values of the array have been filled, so return.
	if (half < 1){
		return;
	}

	// Looping through the array and applying the square step.
	for (int x = half; x < mastersize+half; x+=step){
		for (int z = half; z < mastersize+half; z+=step){
			Square(x, z, half, range);
		}
	}
	// Looping through the array and applying the diamond step.
	for (int x = 0; x < mastersize; x+= step){
		for (int z = 0; z<mastersize; z+= step){
				Diamond(x+half , z, half, range);
				Diamond(x, z+half, half, range);
		}
	}

	// Recursive call
	DiamondSquare(half, range/2);

}

void FractalTerrain::DrawTerrain(int size, int waterlevel = 0){	
	material* p_front = &colour;
	vec3 U;
	vec3 V;
	vec3 normal;
	double vertexData[size*6][size];
	vec3 triangleNormals[size*2][size];


	// This commented out code was used for evaluation purposes.
	/*
	ofstream f;
	f.open("eval.txt", fstream::app);
	f << "Rendering Time:";

	clock_t start;
	double duration;
	start = clock();
	*/

	// Calculating the minimum and maximum values of the heightmap.
	float min = 1000;
	float max = -1000;
	for (int x=0;x<=size-1; x++){
		for (int z=1;z<=size-3; z++){
			if (readMap(x, z) < min){
				min = readMap(x, z);
			}
			if (readMap(x, z) > max){
				max = readMap(x, z);
			}
		}
	}

	// Getting the range between the min and max, then using that range to calculate interpolation of a water level.
	double range = max - min;
	double interpolate = 1/range;
	double water = (range/100)*waterlevel;


	for (int x=0; x<=size-1; x++){
		for (int z=0; z<=size-1; z++){
			vertexData[(x*6)][z] = x;
			// If the y coordinate is lower than the calculated water level, set that value to the water level in the vertex data.
			if (HeightMap[x][z] <= min + water){
				vertexData[(x*6)+1][z] = min + water;
			} else {
				vertexData[(x*6)+1][z] = HeightMap[x][z];
			}
			vertexData[(x*6)+2][z] = z;

		}
	}

	// Using the gathered vertex data to calculate the normals for each triangle in the grid.
	for (int x=0; x<=size-1; x++){
		for (int z=0; z<=size-1; z++){
		
		//Obtaining the vectors for the current triangle.
		U = vec3(1, vertexData[((x+1)*6)+1][z] - vertexData[(x*6)+1][z], 0);
		V = vec3(0, vertexData[(x*6)+1][z+1] - vertexData[(x*6)+1][z], 1);

		// Simultaneously finding the cross product of the vectors and normalising it, resulting in the unit normal vector for the triangle.
		normal = normalize(cross(U, V));

		// Assigning the found normal to a temporary array of normal vectors.
		triangleNormals[x*2][z] = normal;

		// Identical to above but for the other triangle in the tile.
		U = vec3(0, vertexData[((x+1)*6)+1][z] - vertexData[((x+1)*6)+1][z+1], 1);
		V = vec3(1, vertexData[(x*6)+1][z+1] - vertexData[((x+1)*6)+1][z+1], 0);

		normal = normalize(cross(U, V));

		triangleNormals[(x*2)+1][z] = normal;

		}
	}

	// Averaging the normals of the triangles surrounding each vertex, if they exist, and assigning that normal to that vertex in the vertex data array.
	for (int x=0; x<=size-1; x++){
		for (int z=0; z<=size-1; z++){
			vec3 N = vec3(0,0,0);
			int count = 0;

			// Upper left.
			if ((x != 0) && (z!=0)){
				N += triangleNormals[((x-1)*2)+1][z-1];
			}
			// Upper right.
			if ((x != 0) && (z!=size-1)){
				N += triangleNormals[(x*2)][z-1];
				N += triangleNormals[(x*2)+1][z-1];
			}
			// Lower left.
			if ((x != size-1) && (z!=0)){
				N += triangleNormals[((x*2))][z];
				N += triangleNormals[(x*2)+1][z];

			}
			// Lower right.
			if ((x != size-1) && (z!=size-1)){
				N += triangleNormals[(x*2)][z];

				count+=1;
			}

			normal = normalize(N);

			vertexData[(x*6)+3][z] = normal[0];
			vertexData[(x*6)+4][z] = normal[1];
			vertexData[(x*6)+5][z] = normal[2];

		
		}
	}

	// Finding the minimum and maximum values again, only using the gathered vertex data instead of reading straight from the heightmap.
	// This is due to the fact that the heightmap remains the sameas when generated, while the vertex data may have been adjusted by the water level.
	min = 1000;
	max = -1000;
	for (int x=1;x<=size-3; x++){
		for (int z=1;z<=size-3; z++){
			if (vertexData[(x*6)+1][z] < min){
				min = vertexData[(x*6)+1][z];
			}
			if (vertexData[(x*6)+1][z] > max){
				max = vertexData[(x*6)+1][z];
			}
		}
	}

	// Calculating an interpolation ratio for the colour of the map, based on the minimum and maximum values.
	range = max - min;
	interpolate = 1/range;

	for (int x=1;x<=size-3; x++){
		for (int z=1;z<=size-3; z++){
			
			// Taking the Y-coor of the current point.
			double height = vertexData[(x*6)+1][z];

			// Assigning the colour of the triangle based on its height.
			p_front = &colour;
			p_front->ambient[1] = (height - min) * interpolate;
			p_front->ambient[2] = 1 - ((height - min) * interpolate);
			p_front->diffuse[1] = (height - min) * interpolate;
			p_front->diffuse[2] = 1 - ((height - min) * interpolate);

			// Telling OpenGL what values to use when shading this point. 
			glMaterialfv(GL_FRONT, GL_AMBIENT,    p_front->ambient);
			glMaterialfv(GL_FRONT, GL_DIFFUSE,    p_front->diffuse);
			glMaterialfv(GL_FRONT, GL_SPECULAR,   p_front->specular);
			glMaterialf(GL_FRONT, GL_SHININESS,   5.0f);

			// Rendering the primitive.
			glBegin(GL_TRIANGLES);
				glNormal3f(vertexData[(x*6)+3][z+1], vertexData[((x)*6)+4][z+1],vertexData[((x)*6)+5][z+1]);
				glVertex3f(x, vertexData[(x*6)+1][z+1], (z+1));
				glNormal3f(vertexData[(x*6)+3][z], vertexData[((x)*6)+4][z],vertexData[((x)*6)+5][z]);
				glVertex3f(x, vertexData[(x*6)+1][z], z);
				glNormal3f(vertexData[((x+1)*6)+3][z], vertexData[((x+1)*6)+4][z],vertexData[((x+1)*6)+5][z]);
  				glVertex3f((x+1), vertexData[((x+1)*6)+1][z], z);
			glEnd();

			// Same as above but for the other triangle in the tile.
			height = vertexData[((x+1)*6)+1][z+1];

			p_front = &colour;
			p_front->ambient[1] = (height - min) * interpolate;
			p_front->ambient[2] = 1 - ((height - min) * interpolate);
			p_front->diffuse[1] = (height - min) * interpolate;
			p_front->diffuse[2] = 1 - ((height - min) * interpolate);

			glBegin(GL_TRIANGLES);

				glNormal3f(vertexData[((x)*6)+3][z+1], vertexData[((x)*6)+4][z+1],vertexData[((x)*6)+5][z+1]);
				glVertex3f((x), vertexData[(x*6)+1][z+1], (z+1));	
				glNormal3f(vertexData[((x+1)*6)+3][z], vertexData[((x+1)*6)+4][z],vertexData[((x+1)*6)+5][z]);
				glVertex3f(x+1, vertexData[((x+1)*6)+1][z], (z));
				glNormal3f(vertexData[((x+1)*6)+3][z+1], vertexData[((x+1)*6)+4][z+1],vertexData[((x+1)*6)+5][z+1]);
				glVertex3f((x+1), vertexData[((x+1)*6)+1][z+1], (z+1));
	
			glEnd();
			

		
		}
	}

	// Evaluation code.
	/*
	duration = (clock() - start ) / (double) CLOCKS_PER_SEC;
	f << duration << "\n\n";
	*/

	
}

// called every time the widget is resized.
void FractalTerrain::resizeGL(int w, int h)
	{
	// Sets the viewport of the widget to the size given.
	glViewport(0, 0, w, h);

	//Enables lighting in OpenGl.
	glEnable(GL_LIGHTING); 
  	glEnable(GL_LIGHT0);   

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	// Sets an orthographic view.
  	glOrtho(-300.0, 300.0, -300.0, 300.0, -300.0, 300.0);

	}

// Paints the widget.
void FractalTerrain::paintGL(){
	// Clears the buffers.
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	//Enables smooth shading.
	glShadeModel(GL_SMOOTH);

	//Sets the matrix to model view for rendering.
	glMatrixMode(GL_MODELVIEW);
	glEnable(GL_DEPTH_TEST);

	//Sets the lighting position and parameters.
	glLoadIdentity();
		GLfloat light_pos[] = {3, 10000, 3, 1};
		glLightfv(GL_LIGHT0, GL_POSITION, light_pos);
  		glLightf (GL_LIGHT0, GL_SPOT_CUTOFF ,1000);
    glPopMatrix();

	glLoadIdentity();
	//Rotates the scene by 30 degrees along the X-Axis, to provide an angled view of the terrain.
	glRotatef(30, 1, 0, 0);
	//Rotates the scene along the Y-Axis, where the exact angle is determined by the rotation slider in TerrainWindow.cpp.
	glRotatef(angle, 0, 1, 0);
	//Scales the scene by a given ratio, depending on the size of the map.
	glScalef(scale, scale, scale);
	//GTranslates the scene so that the center of the terrain is in the center of the viewport, and lowers it a little.
	glTranslatef(-mastersize/2, -5, -mastersize/2);
	//Calls the DrawTerrain function so as to actually render the terrain.
	DrawTerrain(mastersize, waterlevel);
	glPopMatrix();


	glLoadIdentity();
		// Defines how the viewport looks at the scene.
       	gluLookAt(3.,8.,3., 0,0.0,0, 0.0,1.0,0.0);

	glFlush();

	}
